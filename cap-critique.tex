\documentclass[a4paper,twocolumn,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{mathptmx} % times roman, including math
\usepackage[hyphens]{url}
\usepackage{doi}
\usepackage{hyperref}
\usepackage[numbers,sort]{natbib}
\frenchspacing

% People to send this to for review: Henry Robinson, Peter Bailis, Nicolas Liochon, Justin Sheehy
\begin{document}
\sloppy
\date{} % No date
\title{A Critique of the CAP Theorem}
\author{Martin Kleppmann \and Niklas Ekstr{\"o}m}
\maketitle

\subsection*{Abstract}

The so-called \emph{CAP Theorem} is a frequently cited impossibility result in distributed systems,
especially among the new generation of \emph{NoSQL} distributed databases. In this paper we show
that the proof of CAP is incorrect, due to problems in the way it is formalized. We therefore
propose that it should be referred to as \emph{CAP Principle} rather than \emph{CAP Theorem}.
However, it is true that there is a trade-off between replica consistency guarantees and tolerance
of network faults, and in this paper we discuss some alternative results from distributed systems
theory that can help practitioners reason about such trade-offs in their systems.

\section{Background}

Replicated databases maintain copies of the same data on multiple nodes, potentially in disparate
geographical locations, in order to tolerate faults (failures of nodes or communication links) and
to provide lower latency to users (requests can be served by a nearby site). However, implementing
reliable, fault-tolerant applications in a distributed system is difficult: if there are multiple
copies of the data on different nodes, they may be inconsistent with each other, and an application
that is not designed to handle such inconsistencies may produce incorrect results.

In order to provide a simpler programming model to application developers, the designers of
distributed data systems have explored various consistency guarantees. Distributed consistency
models such as linearizability~\cite{Herlihy1990jq}, sequential consistency~\cite{Lamport1979ky},
causal consistency~\cite{Ahamad1995gl} and pipelined RAM (PRAM)~\cite{Lipton1988uh} encapsulate
certain guarantees about the propagation of writes between the replicas of the database, and thus
permit the programmer to ignore the problem of replica divergence to some degree. By analogy,
transaction isolation models such as serializability, snapshot isolation~\cite{Berenson1995kj},
repeatable read and read committed~\cite{Gray1976us} describe certain guarantees about isolation
between concurrently executing transactions, and permit the programmer to ignore the problem of race
conditions to some degree~\cite{Bailis2014vc}.

A strong consistency model like linearizability provides an easy-to-understand guarantee:
informally, all operations behave as if they executed atomically on a \emph{single copy} of the
data. However, this guarantee comes at the cost of reduced performance~\cite{Attiya1994gw} and fault
tolerance~\cite{Davidson1985hv} compared to weaker consistency models. In particular, as we discuss
in this paper, algorithms that ensure a strong consistency property among replicas are sensitive to
message delays and faults in the network. Many real computer networks are prone to unbounded delays
and dropped messages~\cite{Bailis2014jx}, making the fault tolerance of distributed consistency
algorithms an important issue in practice.

A particular kind of fault that has been studied since the 1970s is the \emph{network partition}, a
communication fault that splits the network into subsets of nodes such that nodes in one subset
cannot communicate with nodes in another~\cite{Johnson1975we, Lindsay1979wv, Davidson1985hv}. As
long as the partition exists, any data modifications made in one subset of nodes cannot be visible
to nodes in another subset, since all messages between them are lost. Thus, an algorithm that
maintains the illusion of a single copy may have to delay operations until the partition is healed,
to avoid the risk of introducing inconsistent data in different subsets.

This trade-off was already known in 1975~\cite{Johnson1975we}, but it was rediscovered in the early
2000s, when the web's growing commercial popularity made geographic distribution and high
availability important to many organizations~\cite{Brewer2012tr, Vogels2008ey}. It was originally
called the \emph{CAP Principle} by Fox and Brewer~\cite{Fox1999bs, Brewer2000vd}, where CAP stands
for \emph{Consistency}, \emph{Availability} and \emph{Partition tolerance}. After the principle was
formalized by Gilbert and Lynch~\cite{Gilbert2002il, Gilbert2012bf} it became known as the
\emph{CAP Theorem}.

CAP was adopted by distributed systems practitioners to critique design
decisions~\cite{Hodges2013tj}, and became a rallying cry of the NoSQL movement~\cite{Brewer2012ba}.
It provoked a lively debate about trade-offs in data systems, partly due to its definitions of
consistency, availability and partition tolerance being unclear~\cite{Robinson2010tp}.

The rest of this paper is organized as follows: in section~\ref{sec:definitions} we compare various
definitions of consistency, availability and partition tolerance. We then examine the formalization
of CAP by Gilbert and Lynch~\cite{Gilbert2002il} in section~\ref{sec:proofs}, and show that the
proofs are incorrect. Finally, in section~\ref{sec:alternatives} we discuss some alternatives to CAP
that are useful for reasoning about trade-offs in distributed systems.

\section{CAP Theorem Definitions}\label{sec:definitions}

CAP was originally presented in the form of \emph{``consistency, availability, partition tolerance:
pick any two''} (i.e.\ you can have CA, CP or AP, but not all three). Subsequent debates concluded
that this formulation is misleading, since the distinction between CA and CP is
unclear~\cite{Brewer2012ba, Hale2010we, Robinson2010tp}. Many authors now prefer the following
formulation: if there is no network partition, a system can be both consistent and available; when a
network partition occurs, a system must choose between either consistency (CP) or availability (AP).

Some authors~\cite{Darcy2010ta, Liochon2015vt} define a CP system as one in which a majority of
nodes on one side of a partition can continue operating normally, and a CA system as one that may
fail catastrophically under a network partition (since it is designed on the assumption that
partitions are very rare). However, this definition is not universally agreed, since it is
counterintuitive to label a system as ``available'' if it fails catastrophically under a partition,
while a system that continues partially operating in the same situation is labelled ``unavailable''
(see section~\ref{sec:partitions}).

Disagreement about the definitions of terms like \emph{availability} is the source of many
misunderstandings about CAP. Unclear definitions also sabotage attempts to formalize the
consistency/availability trade-off as a theorem. Indeed, there is considerable divergence between
the informal CAP principle laid out by Brewer, and the formalization by Gilbert and Lynch.

\subsection{Availability}\label{sec:availability}

In practical engineering terms, \emph{availability} usually refers to the proportion of time during
which a service is able to successfully handle requests, or the proportion of requests that receive
a successful response. A response is usually considered successful if it is valid (not an error, and
satisfies the database's safety properties) and it arrives at the client within some timeout, which
may be specified in a \emph{service level agreement} (SLA). Availability in this sense is a metric
that is empirically observed during a period of a service's operation. A service may be available
(up) or unavailable (down) at any given time, but it is nonsensical to say that some software
package or algorithm is `available' or `unavailable' in general, since the uptime percentage is only
known in retrospect, after a period of operation (during which various faults may have occurred).

There is a long tradition of \emph{highly available} and \emph{fault-tolerant} systems, whose
algorithms are designed such that the system can remain available (up) even when some part of the
system is faulty, thus increasing the expected mean time to failure (MTTF) of the system as a whole.
Using such a system does not automatically make a service 100\% available, but it may increase the
observed availability during operation, compared to using a system that is not fault-tolerant.

\subsubsection{The A in CAP}\label{sec:a-in-cap}

Does the A in CAP refer to a property of a system design, or to an observed metric during system
operation? This distinction is unclear. Brewer does not offer a precise definition of availability,
but states that ``availability is obviously continuous from 0 to 100 percent''~\cite{Brewer2012ba},
suggesting an observed metric. Fox and Brewer also use the term \emph{yield} to refer to the
proportion of requests that are completed successfully~\cite{Fox1999bs} (without specifying any
timeout).

On the other hand, Gilbert and Lynch~\cite{Gilbert2002il} write: ``For a distributed system to be
continuously available, every request received by a non-failing node in the system must result in a
response''. (This sentence appears to define a property of \emph{continuous availability}, but the
rest of the paper does not refer to this ``continuous'' aspect.) In order to prove a result about
systems in general, this definition interprets availability as a binary property of a system's
design, not as an observed metric during system operation --- i.e.\ they define a system as being
``available'' or ``unavailable'' based on its algorithms, not its operational status at some point
in time.

Note that Gilbert and Lynch's definition requires \emph{any} non-failed node to be able to generate
valid responses, even if that node is completely isolated from the other nodes. This definition is
at odds with Fox and Brewer's original proposal of CAP, which states that ``data is considered
highly available if a given consumer of the data can always reach \emph{some}
replica''~\cite[emphasis original]{Fox1999bs}.

Gilbert and Lynch's requirement appears to be stronger, since Fox and Brewer's definition allows a
node to refuse requests as long as another node can generate valid responses, and that node is
reachable by the consumer. Indeed, many so-called highly available or fault-tolerant systems are
``unavailable'' under Gilbert and Lynch's definition, even though they may have very high uptime in
practice.

\subsubsection{Failed nodes}\label{sec:failed-node-exception}

Another noteworthy aspect of Gilbert and Lynch's definition of availability is the proviso of
applying only to \emph{non-failed} nodes. This allows the aforementioned definition of a CA system
as one that fails catastrophically if a network partition occurs: if the partition causes all nodes
to fail, then the availability requirement does not apply to any nodes, and thus it is trivially
satisified, even if no node is able to respond to any requests. This is a valid definition, albeit
somewhat counter-intuitive.

\subsection{Consistency}\label{sec:consistency}

Consistency is also an overloaded word in data systems: consistency in the sense of ACID is a very
different property from consistency in CAP~\cite{Brewer2012ba}. In the distributed systems
literature, consistency is usually understood as not one particular property, but as a range of
properties with varying strengths of guarantee. Examples of such consistency models include
linearizability~\cite{Herlihy1990jq}, sequential consistency~\cite{Lamport1979ky}, causal
consistency~\cite{Ahamad1995gl} and PRAM~\cite{Lipton1988uh}. A consistency model is a safety
property regarding the propagation of updates between replicas.

There is some overlap between distributed consistency models (which pertain to systems in which
there are multiple replicas of the data) and transaction isolation models (which pertain to systems
in which there are multiple concurrently executing transactions, usually assuming a single replica).
Transaction isolation models include serializability~\cite{Bernstein1987va}, snapshot
isolation~\cite{Berenson1995kj}, repeatable read and read committed~\cite{Gray1976us}. Bailis et
al.~\cite{Bailis2014vc} demonstrate a unified framework for reasoning about both distributed
consistency and transaction isolation in terms of CAP.

\subsubsection{The C in CAP}\label{sec:c-in-cap}

Fox and Brewer~\cite{Fox1999bs} define the C in CAP as one-copy serializability
(1SR)~\cite{Bernstein1987va}, whereas Gilbert and Lynch~\cite{Gilbert2002il} define it as
linearizability. Those definitions are not identical, but fairly similar.\footnote{Linearizability
is a recency guarantee, whereas 1SR is not. 1SR requires isolated execution of multi-object
transactions, which linearizability does not. Both are ``unavailable'' in the CAP
sense~\cite{Bailis2014vc}.} Both are safety properties~\cite{Alpern1985dg}, i.e.\ restrictions on
the possible executions of the system, ensuring that certain situations never occur.

In the case of linearizability, the situation that may not occur is a \emph{stale read}: stated
informally, if read operation $r$ begins after write operation $w$ has completed, and there are no
intervening writes, then $r$ must return the value written by $w$. Gilbert and Lynch observe that if
$r$ and $w$ occur on different nodes, and those nodes cannot communicate during the time when those
operations are being executed, then the safety property cannot be satisfied, because $r$ cannot know
about the value of $w$.

The C of CAP is sometimes referred to as \emph{strong consistency} (a term that is not formally
defined), and contrasted with \emph{eventual consistency}~\cite{Terry1994fp, Vogels2008ey, Bailis2013jc},
which is often regarded as the weakest level of consistency that is useful to applications. Eventual
consistency means that if a system stops accepting writes and sufficient\footnote{It is not clear
what amount of communication is `sufficient'. A possible formalization would be to require all
replicas to converge to the same value within finite time, assuming fair-loss links (see section
\ref{sec:fairloss}).} communication occurs, then eventually all replicas will converge to the same
value. However, as the aforementioned list of consistency models indicates, it is overly simplistic
to cast `strong' and eventual consistency as the only possible choices.

\subsubsection{Probabilistic consistency}

It is also possible to define consistency as a quantitative metric rather than a safety property.
For example, Fox and Brewer~\cite{Fox1999bs} define \emph{harvest} as ``the fraction of the data
reflected in the response, i.e.\ the completeness of the answer to the query,'' and
probabilistically bounded staleness~\cite{Bailis2012to} studies the probability of a read returning
a stale value, given various assuptions about the distribution of network latencies. However, these
stochastic definitions of consistency are not the subject of CAP.

\subsection{Partition Tolerance}\label{sec:partitions}

A \emph{network partition} has long been defined as a communication failure in which the network is
split into disjoint sub-networks, with no communication possible across
sub-networks~\cite{Johnson1975we}. This is a fairly narrow class of fault, but it does occur in
practice~\cite{Bailis2014jx}, so it is worth studying.

\subsubsection{Assumptions about system model}

It is less clear what \emph{partition tolerance} means. Gilbert and Lynch~\cite{Gilbert2002il}
define a system as partition-tolerant if it continues to satisfy the consistency and availability
properties in the presence of a partition. Fox and Brewer~\cite{Fox1999bs} define
\emph{partition-resilience} as ``the system as whole can survive a partition between data replicas''
(where \emph{survive} is not defined).

At first glance, these definitions may seem redundant: if we say that an algorithm provides some
guarantee (e.g. linearizability), then we expect \emph{all} executions of the algorithm to satisfy
that property, regardless of the faults that occur during the execution.

However, we can clarify the definitions by observing that the correctness of a distributed algorithm
is always subject to assumptions about the faults that may occur during its execution. If you take
an algorithm that assumes fair-loss links and crash-stop processes, and subject it to Byzantine
faults, the execution will most likely violate safety properties that were supposedly guaranteed.
These assumptions are typically encoded in a \emph{system model}, and non-Byzantine system models
rule out certain kinds of fault as impossible (so algorithms are not expected to tolerate them).

Thus, we can interpret \emph{partition tolerance} as meaning ``a network partition is among the
faults that are assumed to be possible in the system.'' Note that this definition of partition
tolerance is a statement about the system model, whereas consistency and availability are properties
of the possible executions of an algorithm. It is misleading to say that an algorithm ``provides
partition tolerance,'' and it is better to say that an algorithm ``assumes that partitions may
occur.''

If an algorithm assumes the absence of partitions, and is nevertheless subjected to a partition, it
may violate its guarantees in arbitrarily undefined ways (including failing to respond even after
the partition is repaired, or deleting arbitrary amounts of data). Even though it may seem that such
arbitrary failure semantics are not very useful, various systems exhibit such behavior in
practice~\cite{Kingsbury2014tk, Kingsbury2015uk}. Making networks highly reliable is very
expensive~\cite{Bailis2014jx}, so most distributed programs must assume that partitions will occur
sooner or later~\cite{Hale2010we}.

\subsubsection{Partitions and fair-loss links}\label{sec:fairloss}

Further confusion arises due to the fact that network partitions are only one of a wide range of
faults that can occur in distributed systems, including nodes failing or restarting, nodes pausing
for some amount of time (e.g.\ due to garbage collection), and loss or delay of messages in the
network. Some faults can be modeled in terms of other faults (for example, Gilbert and Lynch state
that the loss of an individual message can be modeled as a short-lived network partition).

In the design of distributed systems algorithms, a commonly assumed system model is \emph{fair-loss
links}~\cite{Cachin2011wt}. A network link has the fair-loss property if the probability of a
message \emph{not} being lost is non-zero, i.e.\ the link sometimes delivers messages. The link may
have intervals of time during which all messages are dropped, but those intervals must be of finite
duration. On a fair-loss link, message delivery can be made reliable by retrying a message an
unbounded number of times: the message is guaranteed to be eventually delivered after a finite
number of attempts~\cite{Cachin2011wt}.

We argue that fair-loss links are a good model of most networks in practice: faults occur randomly
(not due to malicious activity); messages are lost while the fault is occurring; the fault lasts for
some finite duration (perhaps seconds, perhaps hours), and eventually it is repaired (perhaps after
human intervention). There is no malicious actor in the network who can cause systematic message
loss over unlimited periods of time -- such malicious actors are usually only assumed in the design
of Byzantine fault tolerant algorithms.

Is ``partitions may occur'' equivalent to assuming fair-loss links? Gilbert and
Lynch~\cite{Gilbert2002il} define partitions as ``the network will be allowed to lose arbitrarily
many messages sent from one node to another.'' In this definition it is unclear whether the number
of lost messages is unbounded but finite, or whether it is potentially infinite.

Partitions of a finite duration are possible with fair-loss links, and thus an algorithm that is
correct in a system model of fair-loss links can tolerate partitions of a finite duration.
Partitions of an infinite duration require some further thought, as we shall see in
section~\ref{sec:proofs}.

\section{The CAP Proofs}\label{sec:proofs}

In this section, we build upon the discussion of definitions in the last section, and examine the
proofs of the purported theorems and corollary of Gilbert and Lynch~\cite{Gilbert2002il}
(collectively known as the ``proof of the CAP theorem''). We demonstrate that each of these proofs
is false.

\subsection{Theorem 1}\label{sec:theorem1}

Gilbert and Lynch's Theorem 1 is stated as follows:

\emph{It is impossible in the asynchronous network model to implement a read/write data object that
guarantees the following properties:}
\begin{itemize}
\item \emph{Availability}
\item \emph{Atomic consistency}\footnote{\emph{Atomic consistency} is synonymous with linearizability, and
it is unrelated to the A in ACID.}
\end{itemize}
\emph{in all fair executions (including those in which messages are lost).}

\subsubsection{Counterexample}\label{sec:abd-algorithm}

The simplest way of showing Theorem 1 to be false is by giving a counterexample. The ABD algorithm,
published by Attiya, Bar-Noy and Dolev five years before CAP was proposed~\cite{Attiya1995bm},
implements an atomic (linearizable) read-write register\footnote{ABD~\cite{Attiya1995bm} is an
algorithm for a single-writer multi-reader register. It was extended to the multi-writer case by
Lynch and Shvartsman~\cite{Lynch1997gr}.} in an unreliable asynchronous network, while also
satisfying Gilbert and Lynch's definition of availability.

If ABD is used with fair-loss links, communication is made reliable by retrying messages an
unbounded number of times until they are delivered. Under this assumption, ABD executions of
\emph{read} and \emph{write} operations always terminate provided that a majority of nodes is not
faulty. As the CAP definition of availability only requires operations to terminate (there is no
limit on the response time, as long as it is finite), this meets the CAP definition of availability.

If nodes are permanently partitioned, or a majority of nodes fails, ABD employs a simple solution:
any node that cannot communicate with a majority of nodes is deemed faulty (for example, it crashes
itself). Under the CAP definition of availability, a faulty node is not required to respond to
requests (section~\ref{sec:failed-node-exception}). There is nothing in the definition of CAP that
prohibits nodes from becoming crashed due to network problems.

Defining a minority partition as failed may feel like cheating: the intuition of CAP availability is
that a minority partition should be able to continue processing. However, Gilbert and Lynch's
definition of availability does not capture this intuition correctly, and it is not clear how the
definition should be amended. (Requiring a node to always to respond, even if it has failed, would
be nonsensical.)

\subsubsection{Finite and infinite partitions}

Even if we did redefine availability such that the ABD algorithm is ``unavailable,'' and thus not an
acceptable counterexample, the proof of Theorem 1 would still be problematic.

The proof rests on constructing an execution of an algorithm $A$ in which a write is followed by a
read, while simultaneously a partition exists in the network. However, the algorithm $A$ may never
exhibit such an execution: for example, the algorithm could simply wait until the partition is
healed before allowing the write operation to complete. With any partition of finite duration, $A$
would still satisfy the availability property, because the operations would eventually complete. In
the asynchronous model, which does not make timing assumptions, such waiting is in fact expected.
The proof is therefore false with regard to partitions of finite duration.

Only if the partition is of infinite duration, $A$ is forced to make a choice\footnote{How the
algorithm would make that choice in the absence of clocks -- since this is an asynchronous system
model -- is unclear.} between waiting until the partition heals (which never happens, thus violating
availability) and exhibiting the execution in the proof of Theorem 1 (thus violating
linearizability). We can conclude that the proof of Theorem 1 is only valid in the case of an
infinite partition.

As previously mentioned, infinite partitions cannot occur in fair-loss links, and are usually
considered a Byzantine failure mode. As discussions of CAP are usually in the context of
non-Byzantine system models, we might conclude that Theorem 1 is false in the context in which it is
normally applied.

\subsubsection{Linearizability vs. eventual consistency}

Note that in the case of an infinite partition, no information can ever flow from one sub-network to
the other. Thus, even eventual consistency (replica convergence in finite time, see
section~\ref{sec:c-in-cap}) is not possible in a system with an infinite partition, if availability
is also required.

The CAP theorem is often understood as demonstrating that linearizability cannot be achieved with
high availability, whereas eventual consistency can. In this section we showed that in the only
situation where the proof of Theorem 1 applies (an infinite partition), linearizable and eventually
consistent algorithms \emph{both} violate the availability requirement.

Thus, Theorem 1 does not serve to differentiate between the availability of linearizable and
eventually consistent systems. The common interpretation, namely that Theorem 1 proves the existence
of a trade-off between availability and consistency, is false.

\subsection{Corollary 1.1}\label{sec:corollary}

Gilbert and Lynch's Corollary~1.1 is stated as follows:

\emph{It is impossible in the asynchronous network model to implement a read/write data object that
guarantees the following properties:}
\begin{itemize}
\item \emph{Availability, in all fair executions,}
\item \emph{Atomic consistency, in fair executions in which \emph{no} messages are lost.}
\end{itemize}

The proof of Corollary~1.1 relies on Theorem~1 in a situation where no messages are lost. However,
we showed that the proof of Theorem~1 is only true in the case of an infinite partition, in which
case an infinite number of messages are lost. Thus, Corollary~1.1 is false.

\subsection{Theorem 2}\label{sec:theorem2}

Gilbert and Lynch's Theorem~2 is similar to Theorem~1, except that it is stated in the partially
synchronous network model rather than the asynchronous model.

Theorem~2 is false for the same reasons as Theorem~1: the ABD algorithm provides a counterexample,
and the execution described in the proof need not be exhibited by any algorithm in the case of a
partition of finite duration. For a partition of infinite duration, the aforementioned observation
about eventual consistency holds.

% \subsection{Definition 3 and Theorem 4}\label{sec:theorem4}
%
% Gilbert and Lynch's Definition~3 describes a new replica consistency model called \emph{Delayed-$t$
% consistency}, and a replication algorithm called \emph{modified centralized algorithm}. Theorem~4 is
% stated as follows:
%
% \emph{The modified centralized algorithm is Delayed-$t$ consistent.}
%
% The Delayed-$t$ model is similar to linearizability, except that it falls back to sequential
% consistency in the case where messages are lost. The sequential consistency property is encoded in
% requirement 3 of Definition 3, which states ``The order in $P$ is consistent with the order of
% \emph{read} and \emph{write} requests submitted at each node.''

\section{Alternatives to CAP}\label{sec:alternatives}

In section~\ref{sec:definitions} we explored the definitions of the terms \emph{consistency},
\emph{availability} and \emph{partition tolerance}, and noted that a wide range of ambiguous and
mutually incompatible interpretations have been proposed, leading to widespread confusion. Then,
using Gilbert and Lynch's definition of those terms, we showed in section~\ref{sec:proofs} that the
purported proofs of CAP are incorrect.

This does not mean that things previously thought impossible are actually possible; these
observations only indicate that CAP is not an appropriate tool for making statements about the
possibility or impossibility of systems.

What next? Perhaps an informally specified, rule-of-thumb \emph{CAP Principle} remains a useful tool
for system design, though such a principle would need to clarify which of the many definitions of
section~\ref{sec:definitions} it uses. However, a rule of thumb should not be mistaken for a
theorem, unless formally proved. Perhaps a correct theorem can be salvaged by adopting a better
formalism, but we do not attempt to prove this.

Instead, we refer to several existing results from the distributed systems literature (most of which
in fact predate CAP, but do not seem to be widely known among proponents of CAP). We show how these
results can help us reason about trade-offs between consistency and robustness to network faults
more precisely than CAP ever allowed.

\subsection{Latency and availability}\label{sec:latency-availability}

As discussed in section~\ref{sec:availability}, the latency (response time) of operations is often
important in practice. In most situations, a service that takes a week to respond might as well be
unavailable. A simple timeout is the most common type of failure detector. By contrast, Gilbert and
Lynch's definition of availability explicitly ignores latency.

The problem with latency is that it is more difficult to model. Latency is influenced by many
factors, especially the delay of packets on the network. Many computer networks (including Ethernet
and the Internet) do not guarantee bounded delay, i.e.\ they allow packets to be delayed
arbitrarily. Latencies and network delays are therefore typically described as probability
distributions.

On the other hand, network delay can model a wide range of faults. In network protocols that
automatically retransmit lost packets (such as TCP), transient packet loss manifests itself to the
application as increased delay. Even when the period of packet loss exceeds the TCP connection
timeout, application-level protocols often retry failed requests until they succeed, so the
effective latency of the operation is the time from the first attempt until the successful
completion. Even network partitions can be modelled as large packet delays (up to the duration of
the partition), provided that the duration of the partition is finite and lost packets are
retransmitted an unbounded number of times.

Abadi~\cite{Abadi2012hb} argues that there is a trade-off between consistency and latency, which
applies even when there is no network partition, and which is as important as the
consistency/availability trade-off described by CAP. We go further, and assert that availability
should be modeled in terms of operation latency. For example, we could define a service as available
if it meets its SLA (e.g.\ 99.9\% requests return successfully within 500~ms). This closely matches
our intuitive understanding of availability.

We can then reason about a service's tolerance of network problems by analyzing how operation
latency is affected by changes in network delay, and whether this pushes operation latency over the
limit set by the SLA. If a service can sustain low operation latency, even as network delay
increases dramatically, it is more tolerant of network problems than a service whose operation
latency increases.

\subsection{How operation latency depends on network latency}\label{sec:network-dependence}

To find a replacement for CAP with a latency-centric viewpoint we need to examine how operation
latency is affected by network latency at different levels of consistency. In practice, this depends
on the algorithms and implementation of the particular software being used. However, CAP
demonstrated that there is also interest in theoretical results identifying the fundamental limits
of what can be achieved, regardless of the particular algorithm in use.

There are several impossibility results that set lower bounds on the operation latency that can be
achieved, as a function of the network delay $d$. These results show that any algorithm guaranteeing
a particular level of consistency cannot perform operations faster than the lower bound, and that
lower bound depends on the chosen level of consistency and the type of operation. We summarize these
results in table~\ref{tab:op-latency} and in the following sections.

These analyses are similar to results in complexity theory, which describe the running time of an
algorithm as a function of the size of its input. Here, we describe the latency of an operation as a
function of the network delay.

\begin{table}
    \centering
    \begin{tabular}{ccc}
        Consistency level      & \textit{write} & \textit{read} \\
                               & latency        & latency \\[3pt] \hline \noalign{\vspace{6pt}}
        linearizability        & $O(d)$         & $O(d)$  \\[3pt]
        sequential consistency & $O(d)$         & $O(1)$  \\[3pt]
        causal consistency     & $O(1)$         & $O(1)$  \\[3pt] \hline
    \end{tabular}
    \caption{Lowest possible operation latency at various consistency levels, as a function of
    network delay $d$.}
    \label{tab:op-latency}
\end{table}

\subsubsection{Linearizability}

Attiya and Welch~\cite{Attiya1994gw} show that any algorithm implementing a linearizable read-write
register must have an operation latency of at least $u/2$, where $u$ is the uncertainty of delay in
the network between replicas.\footnote{Attiya and Welch~\cite{Attiya1994gw} originally proved a
bound of $u/4$ for read operations and $u/2$ for write operations. The $u/2$ bound for read
operations is due to Mavronicolas and Roth~\cite{Mavronicolas1999eb}.}

In this proof, network delay is assumed to be at most $d$ and at least $d-u$, so $u$ is the
difference between the minimum and maximum network delay. In many networks, the maximum possible
delay (due to network congestion or retransmitting lost packets) is much greater than the minimum
possible delay (due to the speed of light), so $u \approx d$. If network delay is unbounded,
operation latency is also unbounded.

For the purpose of this survey, we can simplify the result to say that linearizability requires the
latency of read and write operations to be proportional to the network delay $d$.

\subsubsection{Sequential consistency}

Lipton and Sandberg~\cite{Lipton1988uh} show that any algorithm implementing a sequentially
consistent read-write register must have $|r| + |w| \geq d$, where $|r|$ is the latency of a read
operation, $|w|$ is the latency of a write operation, and $d$ is the network delay. Mavronicolas
and Roth~\cite{Mavronicolas1999eb} further develop this result.

This lower bound provides a degree of choice for the application: for example, an application that
performs more reads than writes can reduce the average operation latency by choosing $|r| = 0$ and
$|w| \geq d$, whereas a write-heavy application might choose $|r| \geq d$ and $|w| = 0$. Attiya and
Welch~\cite{Attiya1994gw} describe algorithms for both of these cases.

Choosing $|r| = 0$ or $|w| = 0$ means the operation can complete without waiting for any network
communication (it may still send messages, but need not wait for a response from other nodes). The
latency of such an operation thus only depends on the local database algorithms: it might be
constant-time $O(1)$, or it might be $O(\log n)$ where $n$ is the size of the database, but either
way it is independent of the network delay $d$.

In table~\ref{tab:op-latency} we have summarized sequential consistency as having fast reads and
slow writes (constant-time reads, and write latency proportional to network delay), although these
roles can be swapped if an application prefers fast writes and slow reads.

\subsubsection{Causal consistency}

If sequential consistency allows the latency of \emph{some} operations to be independent of network
delay, which level of consistency allows \emph{all} operation latencies to be independent of the
network? Mahajan, Alvisi and Dahlin~\cite{Mahajan2011wz} show that causal
consistency~\cite{Ahamad1995gl} with eventual convergence is the strongest possible consistency
guarantee with this property.

Read Your Writes~\cite{Terry1994fp}, PRAM~\cite{Lipton1988uh} and other weak consistency models (all
the way down to eventual consistency, which provides no safety property~\cite{Bailis2013jc}) are
weaker than causal consistency, and thus achievable without waiting for the network. These
consistency models are all ``available'' in Gilbert and Lynch's sense~\cite{Bailis2014vc}.

If tolerance of network delay is the only consideration, causal consistency is the optimal
consistency level. There may be other reasons for choosing weaker consistency levels (for example,
the metadata overhead of tracking causality~\cite{CharronBost1991ec}), but these trade-offs are
outside of the scope of this discussion, as they are also outside the scope of CAP.

\subsection{Heterogeneous delays}

A limitation of the results in section~\ref{sec:network-dependence} is that they assume the
distribution of network delays is the same between every pair of nodes. This assumption is not true
in general: for example, network delay between nodes in the same datacenter is likely to be much
lower than between geographically distributed nodes communicating over WAN links.

If we model network faults as periods of increased network delay
(section~\ref{sec:latency-availability}), then a network partition is a situation in which the delay
between nodes within each partition remains small, while the delay across partitions increases
dramatically (up to the duration of the partition).

For $O(d)$ algorithms, which of these different delays do we need to assume for $d$? The answer
depends on the communication pattern of the algorithm. For example, the ABD algorithm
(section~\ref{sec:abd-algorithm}) needs to wait for responses from a majority of replicas, so $d$ is
the largest among the fastest majority.

\subsection{Disconnected operation}\label{sec:disconnected}

The big-O notation for operation latency ignores constant factors (such as the number of network
round-trip times required by an algorithm), but it captures the essence of what we need to know for
building systems that can tolerate network faults: what happens if network delay dramatically
degrades? In a $O(d)$ algorithm, operation latency may increase to be as large as the duration of
the fault (i.e.\ minutes or even hours), whereas a $O(1)$ algorithm remains unaffected.

If the SLA calls for operation latencies that are significantly shorter than the duration of a
fault, a $O(1)$ algorithm is required. In such algorithms, the time until replica convergence is
still proportional to $d$, but convergence is decoupled from operation latency.

Another way of looking at this is that a $O(1)$ algorithm supports \emph{disconnected} or
\emph{offline operation}. This is an important use case in practice: for example, offline support
has long been used in network file systems~\cite{Kistler1992bt} and automatic teller
machines~\cite{Brewer2012tr}. Apps running on mobile devices also often need to support offline
reading and writing of data, with any updates asynchronously propagated when an internet connection
is next available.

By thinking about the trade-off between replica consistency and network delay, we can integrate
offline-capable client-side applications and server-side databases into a common conceptual
framework.

% An option for disconnected linearizability is to make a single replica the owner of an object.
% This makes access slower for all other replicas, but allows constant-time access by the owner.
% (Mavronicolas and Roth, 1992)

% Brewer states that ``there is little reason to forfeit C or A when the system is not
% partitioned''~\cite{Brewer2012ba}, yet many distributed datastores (e.g.\ Dynamo, Riak, Cassandra
% and Voldemort) don't provide linearizabile consistency, even in the absence of
% partitions~\cite{Abadi2012hb}. The reduced consistency allows these systems to offer lower latency,
% and avoids the difficult problem of detecting whether the cluster is currently partitioned (which
% would be required in order to have a ``partition mode'' that is distinct from normal operation).
% Thus, these datastores that optimize for availability in the CAP sense can be thought to be always
% operating in ``partition mode''.

\section{Conclusion}

Even though the CAP Theorem is false (so it is not a theorem), the informally defined CAP principle
may still be useful for designing practical systems.

\cite{Lynch1989kj}
\cite{Fischer1985tt}
\cite{Sewell2010fj}



{\footnotesize
\bibliographystyle{plainnat}
\bibliography{references}{}}
\end{document}
